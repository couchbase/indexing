## Terminologies

**KV cluster** - Tightly interconnected system of nodes that host one or more
Couchbase buckets.

**Bucket** - Logically independent collection of {key,value} pairs that are
stored and serviced by KV cluster. A single cluster can host more than one
bucket.

**Vbucket** - Otherwise called Virtual-bucket, divides each bucket into fixed
blocks of storage to facilitate elasticity and re-balance in KV cluster.

**KV master** - When a node starts hosting a _vbucket_ as master that node is
designated as KV-master for that _vbucket_.

**KV replica** - For every vbucket there can be one or more replica stored in
a different node. When KV-master for a vbucket fails or removed from the
cluster, one of its replica can be used as the new master. The node hosting the
new master is called KV-master.

**Vbuuid** - Vbucket Universally Unique ID, is a 64-bit number generated by the
KV-master for a vbucket when ever it starts hosting the vbucket due to bucket
creation or dirty failover from another KV-master.

**Projection** - Application developers can define expressions through N1QL
DDLs that will be applied to kv-documents, in JSON format, to generate
secondary keys. The process of fetching the mutations from kv and applying
expressions on them is done by the [projector](projector.md) component.

**UPR** - Universal Protocol for Replication aims to connect different parts
of the system like, disk persistence, replication, XDCR, secondary index with
KV cluster.
[Details.](https://github.com/couchbaselabs/cbupr/blob/master/overview.md)

**Failover log** - Per vbucket list of {vbuuid,seqno} tuple generated by KV
master that has started hosting the vbucket. Refer to UPR documents for more
details.

**Sequence number** - Sequence number is monotonically increasing 64-bit
number for each vbucket. They are important to the system, because they are
the ones which provide a notion of time to the system. There could be gaps in
sequence number due to de-duplication. Refer to UPR documentation for more.

**index** - Index generally means a single sorted list of secondary keys based
on DDLs expression. Index can further be organized as partitions and slices,
and can be spread across multiple nodes.

**local-indexer** - A node in secondary-index-cluster that participates in
building an index.

**index-manager** - Secondary cluster manager that maintains system wide
meta-data, configuration and gather system statistics. Multiple instance of
index-manager run on several nodes, a master is elected among them, and the
master continuously replicates the system information across other instances.

**Participant nodes** - List of all nodes in the secondary-index-cluster that
are active and ready to accept mutations and query.

**Partition** - A single secondary index split into partitions where each
partition is hosted by a single indexer-node. Partition is the fundamental
unit of re-balancing within the secondary cluster.

**Timestamp** - A timestamp is the same as a vector clock, with each clock
(integer) represents an internal event counter per vbucket, a list of
{vbucket.no,sequence.no} tuple. Since secondary index don't use a globally
synchronized clock strict point-in-time timestamp is not possible, but
timestamps can provide an approximation of point-in-time query and
read-your-own-write query. Also, note that a timestamp depends on the observer
that sees those vbucket events.

When a component receive mutation, or projected mutation for a vbucket, it
will update its timestamp vector for that vbucket. Components in a system will
always receive mutations for the same vbucket in strict order, but across
vbuckets components will receive mutations out of order. This means that
timestamps can be generated out-of-order across vbuckets for different
components inside the system.

**High-Watermark Timestamp** - HW timestamp represents all the latest vbucket
events observed by an indexer node. A particular UPR mutation may only be sent
to a subset of index nodes. Therefore, each node may have a different HW
timestamp, since each observe a different set of vbucket events. A SYNC message
can be sent from the projector to all indexer nodes to force their vector clock
to be updated/synchronized for specific vbuckets.

**Failover Timestamp** - Failover timestamp is computed by local-indexer-node
during kv-rollback, that is, when kv-cluster goes through unexpected data loss.
Failover timestamp is calculated by local-indexer-node to figure out the
correct persistent timestamp and rollback to corresponding persistent snapshot.

**Restart Timestamp** - Restart timestamp is calculated by index-manager and
posted to projector, to re-connect with KV-cluster for newer set of UPR
mutations starting from sequence number that is not greater than the
restart-timestamp.

**Stability Timestamp** - Index manager periodically identifies stability
timestamp vector and publishes it to participating indexer-nodes. Locally
indexer nodes will flush mutation queue to the tip. Note that the tip may not
yet be flushed to disk.

**Persistent Timestamp** - One of the stability timestamp becomes persistent
timestamp, flushed to disk, snapshotted (hence it is sometimes referred as
_snapshot timestamp_) and the snapshot preserves the persistent timestamp
information along with it.

**Scan Timestamp** - For every scan request which requires stability,
Indexer will choose a Scan Timestamp from the available Stability Timestamps
or KV timestamp(in case of session consistency). All Indexers participating
in the scan, will return results from a snapshot which matches this Scan
Timestamp.

**Initial Build Timestamp** - For initial build of a newly created index,
the current Timestamp of KV(when initial build starts) is choosen as
Initial Build Timestamp. When index has processed mutations till this point,
it is marked as initial build complete and ready for query.

**Mutation Queue** - In memory queue per vbucket maintained inside
local-indexer-node. System-wide UPR mutations will be gathered in this queue
and flushed into the backend when the queue exactly matches the stability
timestamp issued by index-manager.

**Catchup Queue** - In memory queue per vbucket maintained inside
local-indexer-node. Sometimes, local-indexer-node might have to recover from
failures in which case it could be falling behind the main stream of
projected-mutations. In those cases, they can instantiate a separate data-path
to KV-cluster via projector to get mutations that are required to catchup with
main stream mutations.

**Backfill Queue** - In memory queue per Bucket maintained inside
local-indexer-node. This queue is used by Indexer to store mutations for
the initial index build.

**Stability Snapshot** - Tip of the backend that matches a stability
timestamp.

**Persistent Snapshot** - Snapshot generated by flushing the tip of the
backend's stability snapshot to disk. Persistent timestamp is flushed along
with the snapshot.

**KV-reconnection** - A relative harmless scenario when one or more UPR
connection with KV cluster is lost, or when one of the stateless component
like projector or router crashes.

**KV-rollback** - A situation where KV has gone through unclean failover but
secondary cluster is operating in normal mode.

**Local indexer recovery** - When a participating indexer-node, that maintains
a subset of index data crashes it will try to independently recover from its
persistent snapshot and rejoin with rest of the system. Other crashes can also
happen in secondary cluster. When a stateless component like projector or
router crashes, they are restarted by monitor program and acquire the system
state from index-manager. If master index-manager crashes, a new master is
elected from other instances of it.

**Forward Index** - Main persistence structure for secondary index. This typically
has the format of <secondary_key, docid> and allows lookup/scan queries based on the
secondary key.

**Back Index** - Auxiliary persistence structure for secondary index. This typically
has the format of <doc_id, secondary_key>. The main usage of a back-index is in
maintainence of the Forward Index when the source document gets mutated. It facilitates
in looking up the old secondary key associated with a given document. This old secondary
key can then be looked up and replaced/deleted based on the mutation.

**Tearing Read** - Tearing Read is a problem of non-isolated results in distributed indexes
under concurrent modification. For a detailed explanation of the problem, please read
[Reference 3](https://docs.google.com/document/d/1Y_aXMUBzEvLf8PO8CJYv5eYiQmKsNYzMr6Fq30Cl6xg/edit#heading=h.phqy8trsrvu4).

**topology** - Collection of local-indexer nodes take part in building and
servicing secondary index. For any given index a subset of local-indexer nodes
will be responsible for building the index, some of them acting as master and
few others acting as active replicas. Topology also defines partitions and
slices for an index.

**Topic** - Topic is a concept used in the pub-sub model followed by Router.
Projector publishes key versions on "topics" which the Router can (based on topology)
translate to a list of destinations this key version needs to be sent to.
Typical topics are MaintenanceTopic, CatchupTopic, BackfillTopic.

**Stable Scan** - A scan which is run against a Stability Timestamp(i.e. a
snapshot of the data) across multiple Indexer nodes so it avoids problems
such as `Tearing Reads`.  A Stable Scan is also repeatable(in case query is
holding an open cursor on the results).
